{"version":3,"sources":["StackRouter.js"],"names":["behavesLikePushAction","action","type","NavigationActions","NAVIGATE","StackActions","PUSH","defaultActionCreators","isResetToRootStack","RESET","key","routeConfigs","stackConfig","childRouters","routeNames","Object","keys","forEach","routeName","screen","router","initialRouteParams","getCustomActionCreators","initialRouteName","initialChildRouter","getInitialState","route","childRouter","undefined","childState","childAction","init","params","getStateForAction","isTransitioning","index","routes","navigate","initialRouteKey","getParamsForRouteAndAction","routeConfig","getPathAndParamsForRoute","getActionForPathAndParams","getComponentForState","state","activeChildRoute","getComponentForRouteName","getActionCreators","navStateKey","pop","n","popToTop","push","replace","replaceWith","newKey","reset","actions","length","dismiss","back","activeChildRouter","StateUtils","replaceAt","SET_PARAMS","slice","reverse","childRoute","nextRouteState","newState","replaceAndPrune","immediate","lastRouteIndex","findIndex","r","childRouterNames","i","childRouterName","initChildRoute","navigatedChildRoute","routeToPush","POP_TO_TOP","REPLACE","routeIndex","COMPLETE_TRANSITION","toChildKey","lastRoute","find","indexOf","newStackActions","map","newStackAction","BACK","POP","backRouteIndex","Math","max","backRoute","keyIndex","preserveFocus","includes","getPathAndParamsForState","path","getScreenOptions","defaultNavigationOptions"],"mappings":"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","sourcesContent":["import * as NavigationActions from '../NavigationActions';\nimport * as StackActions from './StackActions';\nimport createConfigGetter from './createConfigGetter';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport StateUtils from '../StateUtils';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport invariant from '../utils/invariant';\nimport { generateKey } from './KeyGenerator';\nimport { createPathParser } from './pathUtils';\n\nfunction behavesLikePushAction(action) {\n  return (\n    action.type === NavigationActions.NAVIGATE ||\n    action.type === StackActions.PUSH\n  );\n}\n\nconst defaultActionCreators = () => ({});\n\nfunction isResetToRootStack(action) {\n  return action.type === StackActions.RESET && action.key === null;\n}\n\nexport default (routeConfigs, stackConfig = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n\n  const childRouters = {};\n  const routeNames = Object.keys(routeConfigs);\n\n  // Loop through routes and find child routers\n  routeNames.forEach(routeName => {\n    const screen = getScreenForRouteName(routeConfigs, routeName);\n    if (screen && screen.router) {\n      // If it has a router it's a navigator.\n      childRouters[routeName] = screen.router;\n    } else {\n      // If it doesn't have router it's an ordinary React component.\n      childRouters[routeName] = null;\n    }\n  });\n\n  const { initialRouteParams } = stackConfig;\n  const getCustomActionCreators =\n    stackConfig.getCustomActionCreators || defaultActionCreators;\n\n  const initialRouteName = stackConfig.initialRouteName || routeNames[0];\n\n  const initialChildRouter = childRouters[initialRouteName];\n\n  function getInitialState(action) {\n    let route = {};\n    const childRouter = childRouters[action.routeName];\n\n    // This is a push-like action, and childRouter will be a router or null if we are responsible for this routeName\n    if (behavesLikePushAction(action) && childRouter !== undefined) {\n      let childState = {};\n      // The router is null for normal leaf routes\n      if (childRouter !== null) {\n        const childAction =\n          action.action || NavigationActions.init({ params: action.params });\n        childState = childRouter.getStateForAction(childAction);\n      }\n\n      return {\n        key: 'StackRouterRoot',\n        isTransitioning: false,\n        index: 0,\n        routes: [\n          {\n            params: action.params,\n            ...childState,\n            key: action.key || generateKey(),\n            routeName: action.routeName,\n          },\n        ],\n      };\n    }\n\n    if (initialChildRouter) {\n      route = initialChildRouter.getStateForAction(\n        NavigationActions.navigate({\n          routeName: initialRouteName,\n          params: initialRouteParams,\n        })\n      );\n    }\n    const params = (routeConfigs[initialRouteName].params ||\n      route.params ||\n      action.params ||\n      initialRouteParams) && {\n      ...(routeConfigs[initialRouteName].params || {}),\n      ...(route.params || {}),\n      ...(action.params || {}),\n      ...(initialRouteParams || {}),\n    };\n    const { initialRouteKey } = stackConfig;\n    route = {\n      ...route,\n      ...(params ? { params } : {}),\n      routeName: initialRouteName,\n      key: action.key || (initialRouteKey || generateKey()),\n    };\n    return {\n      key: 'StackRouterRoot',\n      isTransitioning: false,\n      index: 0,\n      routes: [route],\n    };\n  }\n\n  function getParamsForRouteAndAction(routeName, action) {\n    let routeConfig = routeConfigs[routeName];\n    if (routeConfig && routeConfig.params) {\n      return { ...routeConfig.params, ...action.params };\n    } else {\n      return action.params;\n    }\n  }\n\n  const {\n    getPathAndParamsForRoute,\n    getActionForPathAndParams,\n  } = createPathParser(childRouters, routeConfigs, stackConfig);\n\n  return {\n    childRouters,\n\n    getComponentForState(state) {\n      const activeChildRoute = state.routes[state.index];\n      const { routeName } = activeChildRoute;\n      if (childRouters[routeName]) {\n        return childRouters[routeName].getComponentForState(activeChildRoute);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getActionCreators(route, navStateKey) {\n      return {\n        ...getCustomActionCreators(route, navStateKey),\n        pop: (n, params) =>\n          StackActions.pop({\n            n,\n            ...params,\n          }),\n        popToTop: params => StackActions.popToTop(params),\n        push: (routeName, params, action) =>\n          StackActions.push({\n            routeName,\n            params,\n            action,\n          }),\n        replace: (replaceWith, params, action, newKey) => {\n          if (typeof replaceWith === 'string') {\n            return StackActions.replace({\n              routeName: replaceWith,\n              params,\n              action,\n              key: route.key,\n              newKey,\n            });\n          }\n          invariant(\n            typeof replaceWith === 'object',\n            'Must replaceWith an object or a string'\n          );\n          invariant(\n            params == null,\n            'Params must not be provided to .replace() when specifying an object'\n          );\n          invariant(\n            action == null,\n            'Child action must not be provided to .replace() when specifying an object'\n          );\n          invariant(\n            newKey == null,\n            'Child action must not be provided to .replace() when specifying an object'\n          );\n          return StackActions.replace(replaceWith);\n        },\n        reset: (actions, index) =>\n          StackActions.reset({\n            actions,\n            index: index == null ? actions.length - 1 : index,\n            key: navStateKey,\n          }),\n        dismiss: () =>\n          NavigationActions.back({\n            key: navStateKey,\n          }),\n      };\n    },\n\n    getStateForAction(action, state) {\n      // Set up the initial state if needed\n      if (!state) {\n        return getInitialState(action);\n      }\n\n      const activeChildRoute = state.routes[state.index];\n\n      if (\n        !isResetToRootStack(action) &&\n        action.type !== NavigationActions.NAVIGATE\n      ) {\n        // Let the active child router handle the action\n        const activeChildRouter = childRouters[activeChildRoute.routeName];\n        if (activeChildRouter) {\n          const route = activeChildRouter.getStateForAction(\n            action,\n            activeChildRoute\n          );\n          if (route !== null && route !== activeChildRoute) {\n            return StateUtils.replaceAt(\n              state,\n              activeChildRoute.key,\n              route,\n              // the following tells replaceAt to NOT change the index to this route for the setParam action, because people don't expect param-setting actions to switch the active route\n              action.type === NavigationActions.SET_PARAMS\n            );\n          }\n        }\n      } else if (action.type === NavigationActions.NAVIGATE) {\n        // Traverse routes from the top of the stack to the bottom, so the\n        // active route has the first opportunity, then the one before it, etc.\n\n        for (let childRoute of state.routes.slice().reverse()) {\n          let childRouter = childRouters[childRoute.routeName];\n          let childAction =\n            action.routeName === childRoute.routeName && action.action\n              ? action.action\n              : action;\n\n          if (childRouter) {\n            const nextRouteState = childRouter.getStateForAction(\n              childAction,\n              childRoute\n            );\n\n            if (nextRouteState === null || nextRouteState !== childRoute) {\n              const newState = StateUtils.replaceAndPrune(\n                state,\n                nextRouteState ? nextRouteState.key : childRoute.key,\n                nextRouteState ? nextRouteState : childRoute\n              );\n              return {\n                ...newState,\n                isTransitioning:\n                  state.index !== newState.index\n                    ? action.immediate !== true\n                    : state.isTransitioning,\n              };\n            }\n          }\n        }\n      }\n\n      // Handle push and navigate actions. This must happen after the focused\n      // child router has had a chance to handle the action.\n      if (\n        behavesLikePushAction(action) &&\n        childRouters[action.routeName] !== undefined // undefined means it's not a childRouter or a screen\n      ) {\n        const childRouter = childRouters[action.routeName];\n        let route;\n\n        invariant(\n          action.type !== StackActions.PUSH || action.key == null,\n          'StackRouter does not support key on the push action'\n        );\n\n        // Before pushing a new route we first try to find one in the existing route stack\n        // More information on this: https://github.com/react-navigation/rfcs/blob/master/text/0004-less-pushy-navigate.md\n        const lastRouteIndex = state.routes.findIndex(r => {\n          if (action.key) {\n            return r.key === action.key;\n          } else {\n            return r.routeName === action.routeName;\n          }\n        });\n\n        // An instance of this route exists already and we're dealing with a navigate action\n        if (action.type !== StackActions.PUSH && lastRouteIndex !== -1) {\n          // If index is unchanged and params are not being set, leave state identity intact\n          if (state.index === lastRouteIndex && !action.params) {\n            return null;\n          }\n\n          // Remove the now unused routes at the tail of the routes array\n          const routes = state.routes.slice(0, lastRouteIndex + 1);\n\n          // Apply params if provided, otherwise leave route identity intact\n          if (action.params) {\n            const route = state.routes[lastRouteIndex];\n            routes[lastRouteIndex] = {\n              ...route,\n              params: {\n                ...route.params,\n                ...action.params,\n              },\n            };\n          }\n          // Return state with new index. Change isTransitioning only if index has changed\n          return {\n            ...state,\n            isTransitioning:\n              state.index !== lastRouteIndex\n                ? action.immediate !== true\n                : state.isTransitioning,\n            index: lastRouteIndex,\n            routes,\n          };\n        }\n\n        if (childRouter) {\n          // Delegate to the child router with the given action, or init it\n          const childAction =\n            action.action ||\n            NavigationActions.init({\n              params: getParamsForRouteAndAction(action.routeName, action),\n            });\n          route = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            // note(brentvatne): does it make sense to wipe out the params\n            // here? or even to add params at all? need more info about what\n            // this solves\n            ...childRouter.getStateForAction(childAction),\n            routeName: action.routeName,\n            key: action.key || generateKey(),\n          };\n        } else {\n          // Create the route from scratch\n          route = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            routeName: action.routeName,\n            key: action.key || generateKey(),\n          };\n        }\n        return {\n          ...StateUtils.push(state, route),\n          isTransitioning: action.immediate !== true,\n        };\n      } else if (\n        action.type === StackActions.PUSH &&\n        childRouters[action.routeName] === undefined\n      ) {\n        // Return the state identity to bubble the action up\n        return state;\n      }\n\n      // Handle navigation to other child routers that are not yet pushed\n      if (behavesLikePushAction(action)) {\n        const childRouterNames = Object.keys(childRouters);\n        for (let i = 0; i < childRouterNames.length; i++) {\n          const childRouterName = childRouterNames[i];\n          const childRouter = childRouters[childRouterName];\n          if (childRouter) {\n            // For each child router, start with a blank state\n            const initChildRoute = childRouter.getStateForAction(\n              NavigationActions.init()\n            );\n            // Then check to see if the router handles our navigate action\n            const navigatedChildRoute = childRouter.getStateForAction(\n              action,\n              initChildRoute\n            );\n            let routeToPush = null;\n            if (navigatedChildRoute === null) {\n              // Push the route if the router has 'handled' the action and returned null\n              routeToPush = initChildRoute;\n            } else if (navigatedChildRoute !== initChildRoute) {\n              // Push the route if the state has changed in response to this navigation\n              routeToPush = navigatedChildRoute;\n            }\n            if (routeToPush) {\n              const route = {\n                ...routeToPush,\n                routeName: childRouterName,\n                key: action.key || generateKey(),\n              };\n              return {\n                ...StateUtils.push(state, route),\n                isTransitioning: action.immediate !== true,\n              };\n            }\n          }\n        }\n      }\n\n      // Handle pop-to-top behavior. Make sure this happens after children have had a chance to handle the action, so that the inner stack pops to top first.\n      if (action.type === StackActions.POP_TO_TOP) {\n        // Refuse to handle pop to top if a key is given that doesn't correspond\n        // to this router\n        if (action.key && state.key !== action.key) {\n          return state;\n        }\n\n        // If we're already at the top, then we return the state with a new\n        // identity so that the action is handled by this router.\n        if (state.index > 0) {\n          return {\n            ...state,\n            isTransitioning: action.immediate !== true,\n            index: 0,\n            routes: [state.routes[0]],\n          };\n        }\n        return state;\n      }\n\n      // Handle replace action\n      if (action.type === StackActions.REPLACE) {\n        let routeIndex;\n\n        // If the key param is undefined, set the index to the last route in the stack\n        if (action.key === undefined && state.routes.length) {\n          routeIndex = state.routes.length - 1;\n        } else {\n          routeIndex = state.routes.findIndex(r => r.key === action.key);\n        }\n\n        // Only replace if the key matches one of our routes\n        if (routeIndex !== -1) {\n          const childRouter = childRouters[action.routeName];\n          let childState = {};\n          if (childRouter) {\n            const childAction =\n              action.action ||\n              NavigationActions.init({\n                params: getParamsForRouteAndAction(action.routeName, action),\n              });\n            childState = childRouter.getStateForAction(childAction);\n          }\n          const routes = [...state.routes];\n          routes[routeIndex] = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            // merge the child state in this order to allow params override\n            ...childState,\n            routeName: action.routeName,\n            key: action.newKey || generateKey(),\n          };\n          return { ...state, routes };\n        }\n      }\n\n      // Update transitioning state\n      if (\n        action.type === StackActions.COMPLETE_TRANSITION &&\n        (action.key == null || action.key === state.key) &&\n        action.toChildKey === state.routes[state.index].key &&\n        state.isTransitioning\n      ) {\n        return {\n          ...state,\n          isTransitioning: false,\n        };\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find(route => route.key === key);\n        if (lastRoute) {\n          const params = {\n            ...lastRoute.params,\n            ...action.params,\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = {\n            ...lastRoute,\n            params,\n          };\n          return {\n            ...state,\n            routes,\n          };\n        }\n      }\n\n      if (action.type === StackActions.RESET) {\n        // Only handle reset actions that are unspecified or match this state key\n        if (action.key != null && action.key != state.key) {\n          // Deliberately use != instead of !== so we can match null with\n          // undefined on either the state or the action\n          return state;\n        }\n        const newStackActions = action.actions;\n\n        return {\n          ...state,\n          routes: newStackActions.map(newStackAction => {\n            const router = childRouters[newStackAction.routeName];\n\n            let childState = {};\n\n            if (router) {\n              const childAction =\n                newStackAction.action ||\n                NavigationActions.init({\n                  params: getParamsForRouteAndAction(\n                    newStackAction.routeName,\n                    newStackAction\n                  ),\n                });\n\n              childState = router.getStateForAction(childAction);\n            }\n\n            return {\n              params: getParamsForRouteAndAction(\n                newStackAction.routeName,\n                newStackAction\n              ),\n              ...childState,\n              routeName: newStackAction.routeName,\n              key: newStackAction.key || generateKey(),\n            };\n          }),\n          index: action.index,\n        };\n      }\n\n      if (\n        action.type === NavigationActions.BACK ||\n        action.type === StackActions.POP\n      ) {\n        const { key, n, immediate } = action;\n        let backRouteIndex = state.index;\n        if (action.type === StackActions.POP && n != null) {\n          // determine the index to go back *from*. In this case, n=1 means to go\n          // back from state.index, as if it were a normal \"BACK\" action\n          backRouteIndex = Math.max(1, state.index - n + 1);\n        } else if (key) {\n          const backRoute = state.routes.find(route => route.key === key);\n          backRouteIndex = state.routes.indexOf(backRoute);\n        }\n\n        if (backRouteIndex > 0) {\n          return {\n            ...state,\n            routes: state.routes.slice(0, backRouteIndex),\n            index: backRouteIndex - 1,\n            isTransitioning: immediate !== true,\n          };\n        }\n      }\n\n      // By this point in the router's state handling logic, we have handled the behavior of the active route, and handled any stack actions.\n      // If we haven't returned by now, we should allow non-active child routers to handle this action, and switch to that index if the child state (route) does change..\n\n      const keyIndex = action.key ? StateUtils.indexOf(state, action.key) : -1;\n\n      // Traverse routes from the top of the stack to the bottom, so the\n      // active route has the first opportunity, then the one before it, etc.\n      for (let childRoute of state.routes.slice().reverse()) {\n        if (childRoute.key === activeChildRoute.key) {\n          // skip over the active child because we let it attempt to handle the action earlier\n          continue;\n        }\n        // If a key is provided and in routes state then let's use that\n        // knowledge to skip extra getStateForAction calls on other child\n        // routers\n        if (keyIndex >= 0 && childRoute.key !== action.key) {\n          continue;\n        }\n        let childRouter = childRouters[childRoute.routeName];\n        if (childRouter) {\n          const route = childRouter.getStateForAction(action, childRoute);\n\n          if (route === null) {\n            return state;\n          } else if (route && route !== childRoute) {\n            return StateUtils.replaceAt(\n              state,\n              childRoute.key,\n              route,\n              // People don't expect these actions to switch the active route\n              // TODO: We should switch to action.preserveFocus: true for drawer in future\n              action.preserveFocus || action.type.includes('DRAWER')\n            );\n          }\n        }\n      }\n\n      return state;\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n\n    getActionForPathAndParams(path, params) {\n      return getActionForPathAndParams(path, params);\n    },\n\n    getScreenOptions: createConfigGetter(\n      routeConfigs,\n      stackConfig.defaultNavigationOptions\n    ),\n  };\n};\n"]}